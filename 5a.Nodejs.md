# Setup Environment 
## Runtime Javascript
1. JavaScript awalnya dikembangkan untuk digunakan di lingkungan web browser --> JavaScript bisa berinteraksi dengan pengguna melalui inputan dari mouse dan keyboard, serta menampilkan output melalui HTML dan CSS.
2. Kode JS dapat dijalankan di browser dgn Developer Tools --> tulis dan jalankan kode dalam tab console (ctrl + shift + i atau klik kanan -> Inspect Element -> pilih tab console)
3. **Node.js** : runtime JavaScript yang memungkinkan JavaScript untuk berjalan di luar lingkungan browser. Node.js memungkinkan JavaScript untuk berjalan di berbagai platform, termasuk di dalamnya untuk pengembangan back-end website.
4. Node.js memberikan akses JavaScript ke fitur-fitur sistem operasi (membaca dan menulis file, mengirim dan menerima data melalui jaringan, serta membuat dan melayani permintaan HTTP)

## Node.js 
- runtime environment untuk JavaScript yang bersifat open-source dan cross-platform
- dapat menjalankan kode JavaScript di mana pun, tidak hanya terbatas pada lingkungan browser
- menjalankan V8 JavaScript engine (yang juga merupakan inti dari Google Chrome) di luar browser --> Node.js memiliki performa yang tinggi
- menyediakan banyak library/module JavaScript yang membantu menyederhanakan pengembangan aplikasi web, contohnya:
1. **Asynchronous & Event-driven**
- Semua API dari Node.js bersifat asynchronous --> tidak memblokir proses lain saat menunggu satu proses selesai.
- Node.js menggunakan mekanisme event notification untuk mendapatkan respon dari panggilan API sebelumnya. Ini memungkinkan server Node.js untuk menjalankan pemanggilan API berikutnya tanpa menunggu proses sebelumnya selesai
2. **Very Fast**
- Eksekusi kode dengan Node.js sangat cepat karena menggunakan V8 JavaScript Engine dari Google Chrome. Ini membantu dalam meningkatkan kinerja aplikasi yang dikembangkan menggunakan Node.js.
3. **Single Threaded but Highly Scalable**
- menggunakan model single thread dengan event looping. Meskipun menggunakan single thread, Node.js mampu merespons secara asynchronous dan membuat server menjadi lebih scalable dibandingkan dengan server tradisional yang menggunakan banyak thread. Karakteristik ini memungkinkan Node.js untuk cocok digunakan dalam aplikasi dengan proses I/O yang intensif seperti network server atau backend API. Dengan mekanisme ini, Node.js mampu menangani banyak request secara bersamaan tanpa membutuhkan alokasi memori yang besar seperti yang dibutuhkan dalam pendekatan multithreading.
- ketika ada sebuah operasi I/O yang membutuhkan waktu, seperti membaca file dari sistem file atau melakukan panggilan ke database, Node.js tidak akan menunggu operasi tersebut selesai. Sebaliknya, ia akan memasukkan operasi tersebut ke dalam antrian dan melanjutkan menjalankan kode JavaScript lainnya. Setelah operasi I/O selesai, callback yang sesuai akan dimasukkan ke dalam event loop dan dijalankan oleh thread utama.

## Instalasi Node.js dengan NVM 
- Node.js memiliki dua versi rilis, yaitu LTS (Long Term Support) dan current (berisi fitur-fitur baru yang dirilis untuk Node.js)

Ada dua cara dalam memasang Node.js, yakni:
- sesuai dengan dokumentasi yang diberikan Node.js pada halaman resminya, dan
- menggunakan tool bernama Node Version Manager (NVM) -> proses sederhana dan mudah utk naik turunin versi node.js tanpa instalasi ulang

NVM itu khusus untuk MacOS dan Linux tapi klo mau di windows bisa pake nvm-windows di https://github.com/coreybutler/nvm-windows/releases -> unduh nvm-setup.exe -> jalankan installer
buka terminal dalam mode administrator -> cek udah keinstall dgn `nvm -v` 
pasang node.js dgn `nvm install 16`
gunakan versi node dengan `nvm use (versi node.js)`

## Memulai Project JS 
buka folder di js -> buka terminal -> npm init -> enter aja trs -> nanti bakal muncul package.json 
isinya tentang informasi dasar ttg aplikasi yang kita buat, spt nilai package name, version, description, dsb
bikin file js -> jalankan file js dengan `node (namafile.js)`

- Berkas **Run Scripts** otomatis terbentuk saat package.json dibuat dgn init
  Object scripts merupakan objek yang mengandung kumpulan script di dalamnya. Script tersebut dapat dijalankan kapan saja pada proyek kita. Untuk menjalankan script, gunakan perintah `npm run <script-name>`
`npm run test`  `npm run start`

# Module 
- penting untuk bagi project jadi beberapa berkas berdasarkan tugas dan fungsinya -> lebih mudah utk nyari penyebab error
- pake modul js untuk bagi kode js jadi beberapa berkas

## Export & Import 
- modul bekerja dengan cara export dan importing nilai agar bisa digunakan pada berkas lain.
- satu berkas jd terdiri dari 1 module yg dapat diexport menjadi lebih dari satu nilai
- `module.export` untuk export -> properti yg mendefinisikan nilai apa yang akan dieksport dari berkas tsb
- `require()` untuk import atau gunakan object yang sudah di-export 

# Penanganan Error 
- aplikasi eror -> berhenti dan program selanjutnya tidak akan dieksekusi
- problem? bagaimana menangani error agar app tidak crash dan bagaimana membuat custom error utk menandai?

## Try and Catch 
- Try --> taro kode yang kira kira nimbulin error
- Catch --> nangkep blok kode try yg error 
- Object Error punya beberapa properti utama
name : Nama error yang terjadi.
message : Pesan tentang detail error.
stack : Informasi urutan kejadian yang menyebabkan error. Umumnya digunakan untuk debugging karena terdapat informasi baris mana yang menyebabkan error.
```javaScript
try {
  console.log("Awal blok try");   // (1)
  errorCode;                      // (2)
  console.log("Akhir blok try");  // (3)
} catch (error) {
  console.log(error.name);
  console.log(error.message);
  console.log(error.stack);
}
 
/* output
Awal blok try
ReferenceError
errorCode is not defined
ReferenceError: errorCode is not defined
    at file:///home/dicoding/Playground/javascript/CoffeeMachine/error.js:3:5
    at ModuleJob.run (internal/modules/esm/module_job.js:152:23)
    at async Loader.import (internal/modules/esm/loader.js:166:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
*/ 
```
error yang muncul adalah `ReferenceError` karena errorCode dianggap sebagai sebuah variabel atau nilai yang tidak terdefinisi.

## try-catch-finally 
Blok finally akan tetap dijalankan tanpa peduli apa pun hasil yang terjadi pada blok try-catch.
```javaScript
try {
  console.log("Awal blok try");
  console.log("Akhir blok try");
} catch (error) {
  console.log("Baris ini diabaikan");
} finally {
  console.log("Akan tetap dieksekusi");
}
 
/* output
Awal blok try
Akhir blok try
Akan tetap dieksekusi
*/
```

## Throwing Error
melemparkan error ada program sehingga eksekusi kode akan masuk ke blok catch 
`instanceOf` untuk dapatkan tipe dari error yang terjadi -> nantinya bisa bikin percabangan untuk cara nanganin errornya
```javaScript
try {
  // ...
} catch (error) {
  if (error instanceof SyntaxError) {
    console.log(`JSON Error: ${error.message}`);
  } else if (error instanceof ReferenceError) {
    console.log(error.message);
  } else {
    console.log(error.stack);
  }
}
```

## Custom Error 
`JSON.parse` akan konversi data string jadi objek -> kalo format gak sesuai maka akan `SyntaxError`
kalo datanya ada yang kurang dan mau nandain error akibat data kosong -> custom error dengan bikin class
```javaScript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}
 
const json = '{ "age": 30 }';
 
try {
  const user = JSON.parse(json);
 
  if (!user.name) {
    throw new ValidationError("'name' is required.");
  }
  if (!user.age) {
    throw new ValidationError("'age' is required.");
  }
 
  console.log(user.name);
  console.log(user.age);
} catch (error) {
  if (error instanceof SyntaxError) {
    console.log(`JSON Syntax Error: ${error.message}`);
  } else if (error instanceof ValidationError) {
    console.log(`Invalid data: ${error.message}`);
  } else if (error instanceof ReferenceError) {
    console.log(error.message);
  } else {
    console.log(error.stack);
  }
}
 
/* output
Invalid data: 'name' is required.
*/
```
# Asynchronous Process 
- proses menjalankan kode dengan pararel
- callback untuk dapetin nilai dari proses async
- ada operasi yang emang async secara default, kyk fetch() 
- `callback(argumen1, argumen2)`

![image](https://github.com/NiaPutri23/Dicoding-FEBE/assets/57246029/25cbca5a-dfa8-4d33-a6e0-f5c499f22bfc)
https://www.youtube.com/watch?v=wVtdv5BHhno

### setTimeout()
- argumen 1 adalah fungsi yang akan dipanggil secara terjadwal dan async
- argumen 2 adalah delay waktu
```javaScript
console.log('Selamat datang!');
 
setTimeout(() => {
  console.log('Terima kasih sudah mampir, silakan datang kembali!');
}, 3000)
 
console.log('Ada yang bisa dibantu?');
```
Mencetak →  Selamat datang!
Mencetak → Ada yang bisa dibantu?
Menunggu selama tiga detik.
Mencetak → Terima kasih sudah mampir, silakan datang kembali!

### Callback()
- merupakan fungsi yang disisipkan pada fungsi async dan akan dipanggil saat proses dinyatakan selesai
- fungsi callback akan bawa nilai nilai yang dihasilkan dari proses async-> sehingga bisa dipake nilainya
```javaScript
function getUsers(callback) {
  // simulate network delay
  setTimeout(() => {
    const users = ['John', 'Jack', 'Abigail'];
    callback(users);
  }, 3000);
}
getUsers((users) => {
  console.log(users);
});
```
sebuah fungsi getUsers() digunakan untuk mendapatkan daftar pengguna dari internet secara asynchronous. Kemudian, sebuah fungsi callback usersCallback() digunakan untuk menangani hasil dari proses asynchronous tersebut

- Proses yang dijalankan secara asynchronous, biasanya berpotensi menghasilkan error. Misalnya, sebuah fungsi yang mengambil data dari internet akan menghasilkan error ketika jaringan kita bermasalah. Contoh lainnya, ketika berkas tersebut tidak ditemukan, fungsi yang membacanya akan menghasilkan error.
- Sehingga calbback bawa argumen error + data

Promise adalah objek jd harus pake new 

```javaScript
// Contoh fungsi asynchronous yang mengambil data pengguna dari internet
function getUsers() {
  return new Promise((resolve, reject) => {
    // Simulasi pengambilan data dari internet dengan setTimeout
    setTimeout(() => {
      const users = ['John', 'Jack', 'Abigail'];
      resolve(users); // Resolve Promise dengan data pengguna
    }, 3000);
  });
}

// Contoh fungsi asynchronous lain yang mengambil data cuaca berdasarkan lokasi pengguna
function getWeather(location) {
  return new Promise((resolve, reject) => {
    // Simulasi pengambilan data cuaca dari internet dengan setTimeout
    setTimeout(() => {
      const weather = 'Sunny';
      resolve(weather); // Resolve Promise dengan data cuaca
    }, 2000);
  });
}

// Menggunakan Promise untuk menggabungkan data pengguna dan data cuaca
getUsers()
  .then(users => {
    console.log('Users:', users);
    return getWeather('Jakarta'); // Mengambil data cuaca setelah mendapatkan data pengguna
  })
  .then(weather => {
    console.log('Weather:', weather);
    // Menangani data pengguna dan data cuaca di sini
  })
  .catch(error => {
    console.error('Error:', error);
    // Menangani error jika terjadi kesalahan dalam proses asynchronous
  });

```

contoh dr padika 
```javaScript
function halo(nama) {

```
